# Hogisim
## High-Level Project Description
Our group plans to build a digital logic sandbox where users can construct digital circuits using the seven fundamental logic gates: NOT, OR, AND, XOR, NOR, NAND, XNOR.
The sandbox is empty in the beginning. The user can populate the board with multiple instances of fundamental logic gates, an input node which the user can toggle to either 0 or 1, or an output node that is updated at execution.
This tool can serve as a playground for users interested in digital logic or as an educational tool.

## Goals
The goal for the project involves a visual environment, wherein a user can place sprites corresponding to logic gates and other related components on a two-dimensional grid.
The user will use these sprites to construct a composite digital circuit, which can then be executed with particular input and display the expected output for the circuit.
The user should be able to freely modify and rerun the circuit in real time.
The controls should be intuitive after a short learning period and the user experience should be smooth.

## Features
- Modular construction: The user can create individual instances of each type of logic gate and connect them together within specified limitations (see below).
- Simulation: The sandbox environment can be simulated and an output generated by the user's circuit.
- Keyboard interface: The user can use keyboard shortcuts to make navigation and placement more intuitive.

## Potential Features
- Export to file: The user would be able to export their circuit diagram to a file and then import diagrams to new environments as desired.
- Abstraction: The user would be able to combine circuits into a “black-box” and then be able to use that circuits functionality without having to repeatedly use all the required logic gates.

## Limitations
- Only support for combinational circuits. (ex. basic gates, multiplexers, and arithmetic circuits etc.)
- A to-be determined sizing limitation of the circuit

## Project Update (11/23/22)
Our application, Hogism, is split into two main components: the frontend and the backend.
The work is split among the four group members accordingly, with Chris and Jeremey working on the frontend and Jerry and Shyama working on the backend.

### Frontend updates
The frontend architecture consists of a menu and a workspace viewer that can take any of three states: view, edit, and run.
From the menu, the user is able to either create a new, blank workspace, or load a pre-existing workspace from a file.
The user moves a cursor around the workspace using the arrow keys and can make edits using keyboard shortcuts/selections from a adjacent sprites menu.
For more details on the frontend architecture, please see [this document](doc/arch/frontend.md).

One of the key challenges the frontend team has faced is getting adjusted to the large Brick library.
While it is still a work in progress acclimating to a functional programming style and a new library, so far, things are going somewhat smoothly.
Additionally, it has been challenging working out the kinks of representing a 2D grid with a selection cursor in Haskell.
To solve this problem, the Vector library is used with a nested type as to create a 2D vector due to the vector library's constant time complexity for element access.
So far, these are the two primary challenges the frontend team has faced, but there will surely be more, such as converting from the 2D vector representation to the desired graph representation.

The frontend team expects to meet their goals by the project deadline.
While progress has started slow, we suspect it will speed up as we get more comfortable with Haskell and Brick.
Brick has an included list library for displaying menus, which will be useful when implementing the sprite selection menu.
Brick also has a file browser library, which will be useful for the pre-existing workspace loading feature.
These two aforementioned features were potentially ideas that needed to be scraped in favor of a more simple approach so that the project could be finished on time.
However, it seems things should go according to plan from here on out.

### Backend updates
The backend component is a graph structure representing the user's circuit. This graph can be used to compute results, or check for invalid inputs. This graph is not yet implemented, and could take a number of forms:
- A static graph that is compiled from the user's circuit
- A graph that can be navigated and mutated, e.g. via [Zippers](http://learnyouahaskell.com/zippers)

The current exploratory implementation demonstrates that it is possible to compute digital logic using a graph-like structure.

The main challenge for the backend team is thinking ahead to the interaction between user input and the computation for simulating the circuit's outputs. 
Isolated from user interaction, the backend implementation for simulating logic gates is trivial. However, we may want to dynamically update the graph representation of the circuit, which is difficult using a functional approach. In addition, a compilation process may not be trivial either.

Thus far the backend has a baseline implementation for logic gate simulation, so the deadline seems appropriate still.
When the interaction between the frontend and backend components is decided, then the direction for backend implementation will be clearer and a more functional prototype can be implemented.

## Project Timeline
| Goal | Date |
|:---  | :--- |
| Project Description and Goals | 11/09/22 |
| Front-End Board and Movable Logic Objects w/ No Functionality or Connectivity + Back-End Circuit Representation and Solver | 11/19/22 |
| Fully Functional and Complete | 12/07/22 |

## Known Issues
- Output nodes cannot be placed adjacent to each other due to the way in which the back-end searches the matrix
